AWSTemplateFormatVersion: '2010-09-09'
Description: Template with one Lambda invoking four other Lambdas

Parameters:
  Stage:
    Type: String
    Default: MultiTest

Resources:
  # --- Target Lambdas (1-4) ---
  RoleForTargetLambdas:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  TargetLambda1:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "MultiTargetLambda1-${Stage}"
      Handler: index.handler
      Role: !GetAtt RoleForTargetLambdas.Arn
      Runtime: python3.9
      Code: { ZipFile: "exports.handler = async (event) => { console.log('Target 1 reached'); return { target: 1, ...event }; };" }

  TargetLambda2:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "MultiTargetLambda2-${Stage}"
      Handler: index.handler
      Role: !GetAtt RoleForTargetLambdas.Arn
      Runtime: python3.9
      Code: { ZipFile: "exports.handler = async (event) => { console.log('Target 2 reached'); return { target: 2, ...event }; };" }

  TargetLambda3:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "MultiTargetLambda3-${Stage}"
      Handler: index.handler
      Role: !GetAtt RoleForTargetLambdas.Arn
      Runtime: python3.9
      Code: { ZipFile: "exports.handler = async (event) => { console.log('Target 3 reached'); return { target: 3, ...event }; };" }

  TargetLambda4:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "MultiTargetLambda4-${Stage}"
      Handler: index.handler
      Role: !GetAtt RoleForTargetLambdas.Arn
      Runtime: python3.9
      Code: { ZipFile: "exports.handler = async (event) => { console.log('Target 4 reached'); return { target: 4, ...event }; };" }

  # --- Caller Lambda ---
  RoleForCallerLambda:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: InvokeTargetsPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: # Permissions to invoke all targets
                  - !GetAtt TargetLambda1.Arn
                  - !GetAtt TargetLambda2.Arn
                  - !GetAtt TargetLambda3.Arn
                  - !GetAtt TargetLambda4.Arn

  CallerLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "MultiCallerLambda-${Stage}"
      Handler: index.handler
      Role: !GetAtt RoleForCallerLambda.Arn
      Runtime: python3.9
      Code:
        ZipFile: |
          import os, boto3, json
          TARGETS = [
              os.environ['TARGET_1_NAME'],
              os.environ['TARGET_2_NAME'],
              os.environ['TARGET_3_NAME'],
              os.environ['TARGET_4_NAME']
          ]
          lambda_client = boto3.client('lambda')

          def handler(event, context):
              results = []
              for target_name in TARGETS:
                  print(f'Caller invoking {target_name}')
                  try:
                      response = lambda_client.invoke(FunctionName=target_name, Payload=json.dumps(event))
                      payload = json.loads(response['Payload'].read())
                      results.append(payload)
                  except Exception as e:
                      print(f'Error invoking {target_name}: {e}')
                      results.append({'error': str(e), 'target': target_name})
              return results
      Environment:
        Variables: # References to make parsing easier
          TARGET_1_NAME: !Ref TargetLambda1
          TARGET_2_NAME: !Ref TargetLambda2
          TARGET_3_NAME: !Ref TargetLambda3
          TARGET_4_NAME: !Ref TargetLambda4

Outputs:
  CallerLambdaName:
    Value: !Ref CallerLambda
  TargetLambda1Name:
    Value: !Ref TargetLambda1
  TargetLambda2Name:
    Value: !Ref TargetLambda2
  TargetLambda3Name:
    Value: !Ref TargetLambda3
  TargetLambda4Name:
    Value: !Ref TargetLambda4 